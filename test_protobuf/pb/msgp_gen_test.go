package goserbench

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"bytes"
	"math/rand"
	"testing"
	"time"

	"github.com/tinylib/msgp/msgp"
)

func TestMarshalUnmarshalMsgpackUser(t *testing.T) {
	v := MsgpackUser{}
	bts, err := v.MarshalMsg(nil)
	if err != nil {
		t.Fatal(err)
	}
	left, err := v.UnmarshalMsg(bts)
	if err != nil {
		t.Fatal(err)
	}
	if len(left) > 0 {
		t.Errorf("%d bytes left over after UnmarshalMsg(): %q", len(left), left)
	}

	left, err = msgp.Skip(bts)
	if err != nil {
		t.Fatal(err)
	}
	if len(left) > 0 {
		t.Errorf("%d bytes left over after Skip(): %q", len(left), left)
	}
}

func generateMsgpProto() []*MsgpackUser {
	a := make([]*MsgpackUser, 0, 1000)
	for i := 0; i < 1000; i++ {
		a = append(a, &MsgpackUser{
			Id:       randString(32),
			Name:     randString(16),
			Password: randString(18),
			Age:      rand.Int31n(5),
			BirthDay: time.Now().UnixNano(),
			Spouse:   rand.Intn(2) == 1,
			Money:    rand.Float64(),
		})
	}
	return a
}

func BenchmarkMarshalMsgMsgpackUser(b *testing.B) {
	b.StopTimer()
	data := generateMsgpProto()
	b.ReportAllocs()
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		data[rand.Intn(len(data))].MarshalMsg(nil)
	}
}

func BenchmarkAppendMsgMsgpackUser(b *testing.B) {
	v := MsgpackUser{}
	bts := make([]byte, 0, v.Msgsize())
	bts, _ = v.MarshalMsg(bts[0:0])
	b.SetBytes(int64(len(bts)))
	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		bts, _ = v.MarshalMsg(bts[0:0])
	}
}

func BenchmarkUnmarshalMsgpackUser(b *testing.B) {
	validate := true
	b.StopTimer()
	data := generateMsgpProto()
	ser := make([][]byte, len(data))
	for i, d := range data {
		ser[i], _ = d.MarshalMsg(nil)
	}
	b.ReportAllocs()
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		n := rand.Intn(len(ser))
		o := &MsgpackUser{}
		_, err := o.UnmarshalMsg(ser[n])
		if err != nil {
			b.Fatalf("goprotobuf failed to unmarshal: %s (%s)", err, ser[n])
		}
		// Validate unmarshalled data.
		if validate != false {
			d := data[n]
			correct := o.Id == d.Id && o.Name == d.Name && o.Password == d.Password && o.Age == d.Age && o.Spouse == d.Spouse && o.Money == d.Money && o.BirthDay == d.BirthDay //&& cmpTags(o.Tags, i.Tags) && cmpAliases(o.Aliases, i.Aliases)
			if !correct {
				b.Fatalf("unmarshaled object differed:\n%v\n%v", i, o)
			}
		}
	}
}

func TestEncodeDecodeMsgpackUser(t *testing.T) {
	v := MsgpackUser{}
	var buf bytes.Buffer
	msgp.Encode(&buf, &v)

	m := v.Msgsize()
	if buf.Len() > m {
		t.Logf("WARNING: Msgsize() for %v is inaccurate", v)
	}

	vn := MsgpackUser{}
	err := msgp.Decode(&buf, &vn)
	if err != nil {
		t.Error(err)
	}

	buf.Reset()
	msgp.Encode(&buf, &v)
	err = msgp.NewReader(&buf).Skip()
	if err != nil {
		t.Error(err)
	}
}

func BenchmarkEncodeMsgpackUser(b *testing.B) {
	v := MsgpackUser{}
	var buf bytes.Buffer
	msgp.Encode(&buf, &v)
	b.SetBytes(int64(buf.Len()))
	en := msgp.NewWriter(msgp.Nowhere)
	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		v.EncodeMsg(en)
	}
	en.Flush()
}

func BenchmarkDecodeMsgpackUser(b *testing.B) {
	v := MsgpackUser{}
	var buf bytes.Buffer
	msgp.Encode(&buf, &v)
	b.SetBytes(int64(buf.Len()))
	rd := msgp.NewEndlessReader(buf.Bytes(), b)
	dc := msgp.NewReader(rd)
	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err := v.DecodeMsg(dc)
		if err != nil {
			b.Fatal(err)
		}
	}
}
